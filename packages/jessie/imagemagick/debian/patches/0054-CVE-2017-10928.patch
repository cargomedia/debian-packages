From cd8b03158aba399c5f80df2d48e72afbad2c80de Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Tue, 4 Jul 2017 19:39:46 -0400
Subject: [PATCH] CVE-2017-10928

A heap-based buffer over-read in the GetNextToken function in token.c allows remote attackers to obtain
sensitive information from process memory or possibly have unspecified other impact
via a crafted SVG document that is mishandled in the GetUserSpaceCoordinateValue function in coders/svg.c.

origin: https://github.com/ImageMagick/ImageMagick/commit/663e70e90257797f4634ea8dd4a31e0947d1f266
bug: https://github.com/ImageMagick/ImageMagick/issues/539
bug-debian: https://bugs.debian.org/867367

(cherry picked from commit 663e70e90257797f4634ea8dd4a31e0947d1f266)
---
 magick/token.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/magick/token.c b/magick/token.c
index 6fd848730..032e53c62 100644
--- a/magick/token.c
+++ b/magick/token.c
@@ -180,9 +180,13 @@ MagickExport void GetNextToken(const char *start,const char **end,
   register ssize_t
     i;
 
+  size_t
+    length;
+
   assert(start != (const char *) NULL);
   assert(token != (char *) NULL);
   i=0;
+  length=strlen(start);
   p=start;
   while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\0'))
     p++;
@@ -218,6 +222,8 @@ MagickExport void GetNextToken(const char *start,const char **end,
             }
         if (i < (ssize_t) (extent-1))
           token[i++]=(*p);
+        if ((p-start) >= length)
+          break;
       }
       break;
     }
@@ -240,8 +246,12 @@ MagickExport void GetNextToken(const char *start,const char **end,
       if ((p != q) && (*p != ','))
         {
           for ( ; (p < q) && (*p != ','); p++)
+          {
             if (i < (ssize_t) (extent-1))
               token[i++]=(*p);
+            if ((p-start) >= length)
+              break;
+          }
           if (*p == '%')
             if (i < (ssize_t) (extent-1))
               token[i++]=(*p++);
@@ -272,7 +282,11 @@ MagickExport void GetNextToken(const char *start,const char **end,
               token[i++]=(*p);
             if ((*p == ')') && (*(p-1) != '\\'))
               break;
+            if ((p-start) >= length)
+              break;
           }
+        if ((p-start) >= length)
+          break;
       }
       break;
     }
