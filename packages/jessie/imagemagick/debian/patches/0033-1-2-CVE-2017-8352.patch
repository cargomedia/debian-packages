From b8a20ac7081efcf4d77633e8ac110798048f4f96 Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Wed, 26 Apr 2017 17:32:34 -0400
Subject: [PATCH] [1/2] CVE-2017-8352

The ReadXWDImage function in xwd.c allows attackers to cause a denial of service (memory leak) via a crafted file.

bug: https://github.com/ImageMagick/ImageMagick/issues/452
bug-debian: https://bugs.debian.org/862590
origin: https://github.com/ImageMagick/ImageMagick/commit/2917930679a3543e52070668c3adb3d8c183d1f6

(cherry picked from commit 2917930679a3543e52070668c3adb3d8c183d1f6)
---
 coders/xwd.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/coders/xwd.c b/coders/xwd.c
index b163b6acc..3f88bcd76 100644
--- a/coders/xwd.c
+++ b/coders/xwd.c
@@ -336,6 +336,7 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
         count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);
         if (count != sz_XWDColor)
           {
+            colors=(XColor *) RelinquishMagickMemory(colors);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
           }
@@ -366,6 +367,8 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
   length=(size_t) ximage->bytes_per_line*ximage->height;
   if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     }
@@ -378,6 +381,8 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
       length*=ximage->depth;
       if (CheckOverflowException(length,extent,ximage->depth))
         {
+          if (header.ncolors != 0)
+            colors=(XColor *) RelinquishMagickMemory(colors);
           ximage=(XImage *) RelinquishMagickMemory(ximage);
           ThrowReaderException(CorruptImageError,"ImproperImageHeader");
         }
@@ -385,12 +390,16 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
   ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));
   if (ximage->data == (char *) NULL)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
      }
   count=ReadBlob(image,length,(unsigned char *) ximage->data);
   if (count != (ssize_t) length)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage->data=DestroyString(ximage->data);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,"UnableToReadImageData");
@@ -404,6 +413,10 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
+      ximage->data=DestroyString(ximage->data);
+      ximage=(XImage *) RelinquishMagickMemory(ximage);
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
@@ -525,6 +538,8 @@ static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
         */
         if (AcquireImageColormap(image,image->colors) == MagickFalse)
           {
+            if (header.ncolors != 0)
+              colors=(XColor *) RelinquishMagickMemory(colors);
             ximage->data=DestroyString(ximage->data);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
