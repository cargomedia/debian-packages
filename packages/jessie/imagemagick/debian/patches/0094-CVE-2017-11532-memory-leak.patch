From 296189ecadf86bfeb7c145a7284da2a8ac04aceb Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Sun, 23 Jul 2017 17:08:48 -0400
Subject: [PATCH] CVE-2017-11532: memory leak

When Imagemagick processes a crafted file in convert, it can lead to a Memory Leak in the WriteMPCImage() function in coders/mpc.c.
The previous fix was incomplete.

This fix was merged with 718504b0b79a4418a12a970b5c0bf8bfa0ae1306 in order to get  bissectibility

bug: https://github.com/ImageMagick/ImageMagick/issues/563
origin:  https://github.com/ImageMagick/ImageMagick/commit/184a047627aa564b7062d2462aef668155caa390,
 https://github.com/ImageMagick/ImageMagick/commit/718504b0b79a4418a12a970b5c0bf8bfa0ae1306
bug-debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=869726
---
 magick/blob.h  |  3 ++-
 magick/cache.c | 32 ++++++++++++++++----------------
 2 files changed, 18 insertions(+), 17 deletions(-)

diff --git a/magick/blob.h b/magick/blob.h
index a90c62b60..569d11c2e 100644
--- a/magick/blob.h
+++ b/magick/blob.h
@@ -31,7 +31,8 @@ typedef enum
 {
   ReadMode,
   WriteMode,
-  IOMode
+  IOMode,
+  PersistMode
 } MapMode;
 
 extern MagickExport FILE
diff --git a/magick/cache.c b/magick/cache.c
index 7c2260162..81353c5dd 100644
--- a/magick/cache.c
+++ b/magick/cache.c
@@ -1064,7 +1064,7 @@ static inline void RelinquishPixelCachePixels(CacheInfo *cache_info)
     {
       (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);
       cache_info->pixels=(PixelPacket *) NULL;
-      if (cache_info->mode != ReadMode)
+      if ((cache_info->mode != ReadMode) && (cache_info->mode != PersistMode))
         (void) RelinquishUniqueFileResource(cache_info->cache_filename);
       *cache_info->cache_filename='\0';
       RelinquishMagickResource(MapResource,cache_info->length);
@@ -1073,7 +1073,7 @@ static inline void RelinquishPixelCachePixels(CacheInfo *cache_info)
     {
       if (cache_info->file != -1)
         (void) ClosePixelCacheOnDisk(cache_info);
-      if (cache_info->mode != ReadMode)
+      if ((cache_info->mode != ReadMode) && (cache_info->mode != PersistMode))
         (void) RelinquishUniqueFileResource(cache_info->cache_filename);
       *cache_info->cache_filename='\0';
       RelinquishMagickResource(DiskResource,cache_info->length);
@@ -3864,6 +3864,8 @@ static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
       return(MagickTrue);
     }
   status=AcquireMagickResource(AreaResource,cache_info->length);
+  if (cache_info->mode == PersistMode)
+    status=MagickFalse;
   length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));
   if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))
     {
@@ -3981,7 +3983,8 @@ static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
         "CacheResourcesExhausted","`%s'",image->filename);
       return(MagickFalse);
     }
-  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))
+  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode) &&
+      (cache_info->mode != PersistMode))
     {
       (void) ClosePixelCacheOnDisk(cache_info);
       *cache_info->cache_filename='\0';
@@ -4127,7 +4130,7 @@ MagickExport MagickBooleanType PersistPixelCache(Image *image,
     *magick_restrict clone_info;
 
   Image
-    clone_image;
+    *clone_image;
 
   MagickBooleanType
     status;
@@ -4198,19 +4201,16 @@ MagickExport MagickBooleanType PersistPixelCache(Image *image,
   /*
     Clone persistent pixel cache.
   */
-  clone_image=(*image);
-  clone_info=(CacheInfo *) clone_image.cache;
-  image->cache=ClonePixelCache(cache_info);
-  cache_info=(CacheInfo *) ReferencePixelCache(image->cache);
-  (void) CopyMagickString(cache_info->cache_filename,filename,MaxTextExtent);
-  cache_info->type=DiskCache;
-  cache_info->offset=(*offset);
-  cache_info=(CacheInfo *) image->cache;
-  status=OpenPixelCache(image,IOMode,exception);
-  if (status != MagickFalse)
-    status=ClonePixelCacheRepository(cache_info,clone_info,&image->exception);
+  clone_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);
+  if (clone_image == (Image *) NULL)
+    return(MagickFalse);
+  clone_info=(CacheInfo *) clone_image->cache;
+  (void) CopyMagickString(clone_info->cache_filename,filename,MaxTextExtent);
+  clone_info->mode=PersistMode;
+  clone_info->offset=(*offset);
+  status=ClonePixelCacheRepository(clone_info,image->cache,exception);
   *offset+=cache_info->length+page_size-(cache_info->length % page_size);
-  clone_info=(CacheInfo *) DestroyPixelCache(clone_info);
+  clone_image=DestroyImage(clone_image);
   return(status);
 }
 
